/* eslint-disable @typescript-eslint/restrict-template-expressions */
import fs from 'fs/promises';
import path from 'path';
import readline from 'readline/promises';
import {Project} from 'ts-morph';

type KaitoConfig = {
	out: string;
	src: string;
	watch?: string[];
};

const rl = readline.createInterface({
	input: process.stdin,
	output: process.stdout,
});

async function readConfig(): Promise<KaitoConfig> {
	const configPath = path.join(process.cwd(), 'kaito.config.json');
	const configExists = await checkDirectoryOrFile(configPath);

	if (!configExists) {
		const answer = await rl.question('There is no kaito.config.json file, would you like to create one? (y/n): ');
		if (answer.toLowerCase() === 'y') {
			await createConfig();
		} else {
			rl.close();
			throw new Error('User said no, aborting config creation.');
		}

		rl.close();
		return readConfig(); // Recursive call to read the newly created config
	}

	const configContent = await fs.readFile(configPath, 'utf-8');
	return JSON.parse(configContent) as KaitoConfig;
}

async function checkDirectoryOrFile(dir: string) {
	return fs
		.access(dir)
		.then(() => true)
		.catch(() => false);
}

async function createConfig() {
	const configPath = path.join(process.cwd(), 'kaito.config.json');

	const srcDir = await rl.question(
		"Enter the file location of your Kaito router (e.x: '../../../api/src/router.ts'): "
	);
	if (!srcDir.trim()) {
		throw new Error('No source directory provided');
	}

	if (!(await checkDirectoryOrFile(srcDir))) {
		throw new Error('Source directory does not exist');
	}

	const outDir =
		(await rl.question("Enter where you want the generated types to be outputted (e.x: './src/utils/kaito': ")) || '.';
	if (!outDir.trim()) {
		throw new Error('No output directory provided');
	}

	// Purposely not checking if the directory exists, because we can just create it for them

	await fs.writeFile(
		configPath,
		JSON.stringify(
			{
				$schema: 'https://http.kaito.cloud/cli-config-schema.json',
				src: srcDir,
				out: outDir,
			},
			null,
			2
		)
	);
}

async function generateTypes(config: KaitoConfig) {
	const routerFile = path.join(process.cwd(), config.src);
	const project = new Project();
	const sourceFile = project.addSourceFileAtPath(routerFile);

	const serverConstant = sourceFile.getVariableDeclaration('server');
	if (!serverConstant) {
		throw new Error(`No router found in ${routerFile}, please check to make sure you've exported the router for kaito`);
	}

	const routerOption = serverConstant.getDescendants().find(d => d.getText() === 'router');
	const generatedTypes = project.createSourceFile(
		'kaito.d.ts',
		{},
		{
			overwrite: true,
		}
	);

	generatedTypes.addStatements([
		'// This file was generated by @kaito-http/codegen',
		`export type KaitoRouter = ${routerOption?.getType().getText()}`,
	]);

	await generatedTypes.save();
	console.log('[kaito-http/codegen] Types generated');
	process.exit(0);
}

async function main() {
	const config = await readConfig();
	await generateTypes(config);

	if (process.argv.includes('--watch')) {
		console.log(`Watching for changes in: ${config.src}`);
		// The actual watching is handled by Node.js --watch flag
	}
}

void main();
