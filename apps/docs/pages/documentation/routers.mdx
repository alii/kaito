---
title: Routers
description: Learn about Routers in Kaito, and how you can interface with them in your app
---

import {Callout} from 'nextra-theme-docs';

# Routers

Routers hold all of our routes and their metadata. They can be merged together to allow for separating logic into different files.

## Creating a Router

When using `createUtilities`, you get a `router` function that you can use to create a new router. This can be called as many times as you like, and you can merge routers together with a prefix to create a larger router.

```ts {1,3}
import {createUtilities} from '@kaito-http/core';

export const {getContext, router} = createUtilities(async (req, res) => {
	// ...
});

const app = router().get(...);
```

And then you are safe to use the `router` function around your app, which will guarantee context type safety.

## Router Merging

Routers can be merged, which brings one router's routes into another, with a prefix. This is incredibly useful for larger apps, for example when you have multiple versions of an API.

```ts {4}
import {v1} from './routers/v1';
import {v2} from './routers/v1';

export const api = router().merge('/v1', v1).merge('/v2', v2);
```

You can expect all type information to be carried over as well as the route names and their prefixes.

## `.through()` (Middleware alternative)

Kaito takes a different approach to what most people call "middleware", mainly because of its inpredictable nature. Instead, Kaito offers a `.through()` method so you can easily add functions before the request is handled. `.through()` gives the end developer better type-safety, and most importantly, is much easier to know *when* it will run.

### How to use `.through()`

`.through()` takes in a function that is provided the context (Learn more about context [here](/documentation/context)). You can add as many `.through()` methods as you would like, they will be called in the order they are added.

#### Examples

Take the following snippet:

```ts
const createPost = router().post("/posts", {
  async run({ ctx, body, query, params }) {
    // Do something with the request
    console.log(ctx.user);
    // ^? ctx.user is not defined, this will through a type error, accessing will result in being undefined.
  }
})
```


##### Basic Example

A common approach using `.through()` is adding specific functions before the request is handled for only specific routes. That can look something like this:

```ts

const usersRouter = router()
  .get("/posts", {
    async run({ ctx, body, query, params }) {
      // Some route that doesn't require the user.
      console.log(ctx.user); // <-- Undefined
    }
  })
  .through(async (ctx) => {
    const sessionToken = ctx.sessionToken; // sessionToken is a string that was provided in `createUtilities`.
    const user = await getUserFromSessionToken(sessionToken); // getUserFromSessionToken is a function that provides the user, or null

    return {
      ...ctx,
      user
    }
  })
  .post("/posts", {
    async run({ ctx, body, query, params }) {
      // Do something with the request
      console.log(ctx.user);
      // ^? ctx.user is now a User object, or it is null.
    }
  })
```


##### Stacking `.through()` methods

You can even stack them and add as many `.through()` methods as you would like, they will be called in the order they are added.

<Callout>
	Each `.through()` method is called with the latest context, so you can easily build on top of the existing context.
</Callout>

```ts
const usersRouter = router()
  .get("/posts", {
    async run({ ctx, body, query, params }) {
      // Some route that doesn't require the user.
      console.log(ctx.user); // <-- Undefined
    }
  })
  .through(async (ctx) => {
    const sessionToken = ctx.sessionToken; // sessionToken is a string that was provided in `createUtilities`.
    const user = await getUserFromSessionToken(sessionToken); // getUserFromSessionToken is a function that provides the user, or null

    return {
      ...ctx,
      user
    }
  })
  .post("/posts", {
    async run({ ctx, body, query, params }) {
      // Do something with the request
      console.log(ctx.user);
      // ^? ctx.user is now a User object, or it is null.
    }
  })
  .through(async (ctx) => {
    if(!ctx.user) {
      return {
        ...ctx,
        isAdmin: false,
      }
    }

    const checkIfUserIsAdmin = await checkIfUserIsAdmin(ctx.user);

    return {
      ...ctx,
      isAdmin: checkIfUserIsAdmin
    }
  })
  .delete("/posts", {
    async run({ ctx, body, query, params }) {
      // Now this route has access to ctx.user and ctx.isAdmin
      console.log(ctx.user); // <-- User object or null
      console.log(ctx.isAdmin); // <-- boolean
    }
  })
```